{"ast":null,"code":"import * as Redux from 'redux';\nimport { applyMiddleware, compose, createStore, combineReducers } from 'redux';\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction createReduxStore(bag) {\n  bag.models.forEach(function (model) {\n    return createModelReducer(bag, model);\n  });\n  var rootReducer = createRootReducer(bag);\n  var middlewares = applyMiddleware.apply(Redux, bag.reduxConfig.middlewares);\n  var enhancers = composeEnhancersWithDevtools(bag.reduxConfig.devtoolOptions).apply(void 0, bag.reduxConfig.enhancers.concat([middlewares]));\n  var createStore$1 = bag.reduxConfig.createStore || createStore;\n  var bagInitialState = bag.reduxConfig.initialState;\n  var initialState = bagInitialState === undefined ? {} : bagInitialState;\n  return createStore$1(rootReducer, initialState, enhancers);\n}\n\nfunction createModelReducer(bag, model) {\n  var modelReducers = {};\n  var modelReducerKeys = Object.keys(model.reducers);\n  modelReducerKeys.forEach(function (reducerKey) {\n    var actionName = isAlreadyActionName(reducerKey) ? reducerKey : model.name + \"/\" + reducerKey;\n    modelReducers[actionName] = model.reducers[reducerKey];\n  });\n\n  var combinedReducer = function combinedReducer(state, action) {\n    if (state === void 0) {\n      state = model.state;\n    }\n\n    if (action.type in modelReducers) {\n      return modelReducers[action.type](state, action.payload, action.meta);\n    }\n\n    return state;\n  };\n\n  var modelBaseReducer = model.baseReducer;\n  var reducer = !modelBaseReducer ? combinedReducer : function (state, action) {\n    if (state === void 0) {\n      state = model.state;\n    }\n\n    return combinedReducer(modelBaseReducer(state, action), action);\n  };\n  bag.forEachPlugin('onReducer', function (onReducer) {\n    reducer = onReducer(reducer, model.name, bag) || reducer;\n  });\n  bag.reduxConfig.reducers[model.name] = reducer;\n}\n\nfunction createRootReducer(bag) {\n  var rootReducers = bag.reduxConfig.rootReducers;\n  var mergedReducers = mergeReducers(bag.reduxConfig);\n  var rootReducer = mergedReducers;\n\n  if (rootReducers && Object.keys(rootReducers).length) {\n    rootReducer = function rootReducer(state, action) {\n      var actionRootReducer = rootReducers[action.type];\n\n      if (actionRootReducer) {\n        return mergedReducers(actionRootReducer(state, action), action);\n      }\n\n      return mergedReducers(state, action);\n    };\n  }\n\n  bag.forEachPlugin('onRootReducer', function (onRootReducer) {\n    rootReducer = onRootReducer(rootReducer, bag) || rootReducer;\n  });\n  return rootReducer;\n}\n\nfunction mergeReducers(reduxConfig) {\n  var combineReducers$1 = reduxConfig.combineReducers || combineReducers;\n\n  if (!Object.keys(reduxConfig.reducers).length) {\n    return function (state) {\n      return state;\n    };\n  }\n\n  return combineReducers$1(reduxConfig.reducers);\n}\n\nfunction composeEnhancersWithDevtools(devtoolOptions) {\n  if (devtoolOptions === void 0) {\n    devtoolOptions = {};\n  }\n\n  return !devtoolOptions.disabled && typeof window === 'object' && window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ ? window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__(devtoolOptions) : compose;\n}\n\nfunction isAlreadyActionName(reducerKey) {\n  return reducerKey.indexOf('/') > -1;\n}\n\nvar isObject = function isObject(obj) {\n  return typeof obj === 'object' && obj !== null && !Array.isArray(obj);\n};\n\nvar ifDefinedIsFunction = function ifDefinedIsFunction(func) {\n  return !func || typeof func === 'function';\n};\n\nvar validate = function validate(runValidations) {\n  if (process.env.NODE_ENV !== 'production') {\n    var validations = runValidations();\n    var errors = [];\n    validations.forEach(function (validation) {\n      var isInvalid = validation[0];\n      var errorMessage = validation[1];\n\n      if (isInvalid) {\n        errors.push(errorMessage);\n      }\n    });\n\n    if (errors.length > 0) {\n      throw new Error(errors.join(', '));\n    }\n  }\n};\n\nvar validateConfig = function validateConfig(config) {\n  validate(function () {\n    return [[!Array.isArray(config.plugins), 'init config.plugins must be an array'], [!isObject(config.models), 'init config.models must be an object'], [!isObject(config.redux.reducers), 'init config.redux.reducers must be an object'], [!Array.isArray(config.redux.middlewares), 'init config.redux.middlewares must be an array'], [!Array.isArray(config.redux.enhancers), 'init config.redux.enhancers must be an array of functions'], [!ifDefinedIsFunction(config.redux.combineReducers), 'init config.redux.combineReducers must be a function'], [!ifDefinedIsFunction(config.redux.createStore), 'init config.redux.createStore must be a function']];\n  });\n};\n\nvar validateModel = function validateModel(model) {\n  validate(function () {\n    return [[!model, 'model config is required'], [typeof model.name !== 'string', 'model \"name\" [string] is required'], [model.state === undefined && model.baseReducer === undefined, 'model \"state\" is required'], [!ifDefinedIsFunction(model.baseReducer), 'model \"baseReducer\" must be a function']];\n  });\n};\n\nvar validatePlugin = function validatePlugin(plugin) {\n  validate(function () {\n    return [[!ifDefinedIsFunction(plugin.onStoreCreated), 'Plugin onStoreCreated must be a function'], [!ifDefinedIsFunction(plugin.onModel), 'Plugin onModel must be a function'], [!ifDefinedIsFunction(plugin.onReducer), 'Plugin onReducer must be a function'], [!ifDefinedIsFunction(plugin.onRootReducer), 'Plugin onRootReducer must be a function'], [!ifDefinedIsFunction(plugin.createMiddleware), 'Plugin createMiddleware must be a function']];\n  });\n};\n\nvar validateModelReducer = function validateModelReducer(modelName, reducers, reducerName) {\n  validate(function () {\n    return [[!!reducerName.match(/\\/.+\\//), \"Invalid reducer name (\" + modelName + \"/\" + reducerName + \")\"], [typeof reducers[reducerName] !== 'function', \"Invalid reducer (\" + modelName + \"/\" + reducerName + \"). Must be a function\"]];\n  });\n};\n\nvar validateModelEffect = function validateModelEffect(modelName, effects, effectName) {\n  validate(function () {\n    return [[!!effectName.match(/\\//), \"Invalid effect name (\" + modelName + \"/\" + effectName + \")\"], [typeof effects[effectName] !== 'function', \"Invalid effect (\" + modelName + \"/\" + effectName + \"). Must be a function\"]];\n  });\n};\n\nvar createActionDispatcher = function createActionDispatcher(rematch, modelName, actionName, isEffect) {\n  return Object.assign(function (payload, meta) {\n    var action = {\n      type: modelName + \"/\" + actionName\n    };\n\n    if (typeof payload !== 'undefined') {\n      action.payload = payload;\n    }\n\n    if (typeof meta !== 'undefined') {\n      action.meta = meta;\n    }\n\n    return rematch.dispatch(action);\n  }, {\n    isEffect: isEffect\n  });\n};\n\nvar createDispatcher = function createDispatcher(rematch, bag, model) {\n  var modelDispatcher = rematch.dispatch[model.name];\n  var modelReducersKeys = Object.keys(model.reducers);\n  modelReducersKeys.forEach(function (reducerName) {\n    validateModelReducer(model.name, model.reducers, reducerName);\n    modelDispatcher[reducerName] = createActionDispatcher(rematch, model.name, reducerName, false);\n  });\n  var effects = {};\n\n  if (model.effects) {\n    effects = typeof model.effects === 'function' ? model.effects(rematch.dispatch) : model.effects;\n  }\n\n  var effectKeys = Object.keys(effects);\n  effectKeys.forEach(function (effectName) {\n    validateModelEffect(model.name, effects, effectName);\n    bag.effects[model.name + \"/\" + effectName] = effects[effectName].bind(modelDispatcher);\n    modelDispatcher[effectName] = createActionDispatcher(rematch, model.name, effectName, true);\n  });\n};\n\nfunction createRematchBag(config) {\n  return {\n    models: createNamedModels(config.models),\n    reduxConfig: config.redux,\n    forEachPlugin: function forEachPlugin(method, fn) {\n      config.plugins.forEach(function (plugin) {\n        if (plugin[method]) {\n          fn(plugin[method]);\n        }\n      });\n    },\n    effects: {}\n  };\n}\n\nfunction createNamedModels(models) {\n  return Object.keys(models).map(function (modelName) {\n    var model = createNamedModel(modelName, models[modelName]);\n    validateModel(model);\n    return model;\n  });\n}\n\nfunction createNamedModel(name, model) {\n  return _extends({\n    name: name,\n    reducers: {}\n  }, model);\n}\n\nfunction createRematchStore(config) {\n  var bag = createRematchBag(config);\n  bag.reduxConfig.middlewares.push(createEffectsMiddleware(bag));\n  bag.forEachPlugin('createMiddleware', function (createMiddleware) {\n    bag.reduxConfig.middlewares.push(createMiddleware(bag));\n  });\n  var reduxStore = createReduxStore(bag);\n\n  var rematchStore = _extends({}, reduxStore, {\n    name: config.name,\n    addModel: function addModel(model) {\n      validateModel(model);\n      createModelReducer(bag, model);\n      prepareModel(rematchStore, bag, model);\n      reduxStore.replaceReducer(createRootReducer(bag));\n      reduxStore.dispatch({\n        type: '@@redux/REPLACE'\n      });\n    }\n  });\n\n  addExposed(rematchStore, config.plugins);\n  bag.models.forEach(function (model) {\n    return prepareModel(rematchStore, bag, model);\n  });\n  bag.forEachPlugin('onStoreCreated', function (onStoreCreated) {\n    rematchStore = onStoreCreated(rematchStore, bag) || rematchStore;\n  });\n  return rematchStore;\n}\n\nfunction createEffectsMiddleware(bag) {\n  return function (store) {\n    return function (next) {\n      return function (action) {\n        if (action.type in bag.effects) {\n          next(action);\n          return bag.effects[action.type](action.payload, store.getState(), action.meta);\n        }\n\n        return next(action);\n      };\n    };\n  };\n}\n\nfunction prepareModel(rematchStore, bag, model) {\n  var modelDispatcher = {};\n  rematchStore.dispatch[\"\" + model.name] = modelDispatcher;\n  createDispatcher(rematchStore, bag, model);\n  bag.forEachPlugin('onModel', function (onModel) {\n    onModel(model, rematchStore);\n  });\n}\n\nfunction addExposed(store, plugins) {\n  plugins.forEach(function (plugin) {\n    if (!plugin.exposed) return;\n    var pluginKeys = Object.keys(plugin.exposed);\n    pluginKeys.forEach(function (key) {\n      if (!plugin.exposed) return;\n      var exposedItem = plugin.exposed[key];\n      var isExposedFunction = typeof exposedItem === 'function';\n      store[key] = isExposedFunction ? function () {\n        for (var _len = arguments.length, params = new Array(_len), _key = 0; _key < _len; _key++) {\n          params[_key] = arguments[_key];\n        }\n\n        return exposedItem.apply(void 0, [store].concat(params));\n      } : Object.create(plugin.exposed[key]);\n    });\n  });\n}\n\nvar count = 0;\n\nfunction createConfig(initConfig) {\n  var _initConfig$name, _initConfig$redux$dev, _initConfig$redux;\n\n  var storeName = (_initConfig$name = initConfig.name) != null ? _initConfig$name : \"Rematch Store \" + count;\n  count += 1;\n  var config = {\n    name: storeName,\n    models: initConfig.models || {},\n    plugins: initConfig.plugins || [],\n    redux: _extends({\n      reducers: {},\n      rootReducers: {},\n      enhancers: [],\n      middlewares: []\n    }, initConfig.redux, {\n      devtoolOptions: _extends({\n        name: storeName\n      }, (_initConfig$redux$dev = (_initConfig$redux = initConfig.redux) == null ? void 0 : _initConfig$redux.devtoolOptions) != null ? _initConfig$redux$dev : {})\n    })\n  };\n  validateConfig(config);\n  config.plugins.forEach(function (plugin) {\n    if (plugin.config) {\n      config.models = merge(config.models, plugin.config.models);\n\n      if (plugin.config.redux) {\n        config.redux.initialState = merge(config.redux.initialState, plugin.config.redux.initialState);\n        config.redux.reducers = merge(config.redux.reducers, plugin.config.redux.reducers);\n        config.redux.rootReducers = merge(config.redux.rootReducers, plugin.config.redux.reducers);\n        config.redux.enhancers = [].concat(config.redux.enhancers, plugin.config.redux.enhancers || []);\n        config.redux.middlewares = [].concat(config.redux.middlewares, plugin.config.redux.middlewares || []);\n        config.redux.combineReducers = config.redux.combineReducers || plugin.config.redux.combineReducers;\n        config.redux.createStore = config.redux.createStore || plugin.config.redux.createStore;\n      }\n    }\n\n    validatePlugin(plugin);\n  });\n  return config;\n}\n\nfunction merge(original, extra) {\n  return extra ? _extends({}, extra, original) : original;\n}\n\nvar init = function init(initConfig) {\n  var config = createConfig(initConfig || {});\n  return createRematchStore(config);\n};\n\nvar createModel = function createModel() {\n  return function (mo) {\n    var _mo$reducers = mo.reducers,\n        reducers = _mo$reducers === void 0 ? {} : _mo$reducers,\n        _mo$effects = mo.effects,\n        effects = _mo$effects === void 0 ? {} : _mo$effects;\n    return _extends({}, mo, {\n      reducers: reducers,\n      effects: effects\n    });\n  };\n};\n\nvar index = {\n  init: init,\n  createModel: createModel\n};\nexport default index;\nexport { createModel, init };","map":{"version":3,"sources":["../src/reduxStore.ts","../src/validate.ts","../src/dispatcher.ts","../src/bag.ts","../src/rematchStore.ts","../src/config.ts","../src/index.ts"],"names":["createReduxStore","bag","createModelReducer","rootReducer","createRootReducer","middlewares","Redux","enhancers","composeEnhancersWithDevtools","createStore","bagInitialState","initialState","model","modelReducers","modelReducerKeys","Object","actionName","isAlreadyActionName","combinedReducer","state","action","modelBaseReducer","reducer","onReducer","rootReducers","mergedReducers","mergeReducers","actionRootReducer","onRootReducer","combineReducers","reduxConfig","devtoolOptions","window","reducerKey","isObject","obj","Array","ifDefinedIsFunction","validate","process","validations","runValidations","errors","isInvalid","validation","errorMessage","validateConfig","config","validateModel","validatePlugin","plugin","validateModelReducer","reducerName","reducers","validateModelEffect","effectName","effects","createActionDispatcher","type","modelName","rematch","isEffect","createDispatcher","modelDispatcher","modelReducersKeys","effectKeys","createRematchBag","models","createNamedModels","forEachPlugin","fn","createNamedModel","name","createRematchStore","createEffectsMiddleware","createMiddleware","reduxStore","rematchStore","addModel","prepareModel","addExposed","onStoreCreated","next","store","onModel","plugins","pluginKeys","exposedItem","isExposedFunction","params","count","createConfig","initConfig","storeName","redux","merge","extra","init","createModel","mo"],"mappings":";;;;;;;;;;;;;;;;;;;;;SAiBwBA,gB,CAItBC,G,EAAAA;AACDA,EAAAA,GAAG,CAAHA,MAAAA,CAAAA,OAAAA,CAAmB,UAAA,KAAA,EAAA;AAAA,WAAWC,kBAAkB,CAAA,GAAA,EAA7B,KAA6B,CAA7B;AAAnBD,GAAAA;AAEA,MAAME,WAAW,GAAGC,iBAAiB,CAArC,GAAqC,CAArC;AAEA,MAAMC,WAAW,GAAGC,eAAAA,CAAAA,KAAAA,CAAAA,KAAAA,EAAyBL,GAAG,CAAHA,WAAAA,CAA7C,WAAoBK,CAApB;AACA,MAAMC,SAAS,GAAGC,4BAA4B,CAC7CP,GAAG,CAAHA,WAAAA,CADiBO,cAA4B,CAA5BA,CAAAA,KAAAA,CAAAA,KAAAA,CAAAA,EAEbP,GAAG,CAAHA,WAAAA,CAFaO,SAEbP,CAFaO,MAEbP,CAFaO,CAAlB,WAAkBA,CAEbP,CAFaO,CAAlB;AAIA,MAAMC,aAAW,GAAGR,GAAG,CAAHA,WAAAA,CAAAA,WAAAA,IAApB,WAAA;AACA,MAAMS,eAAe,GAAGT,GAAG,CAAHA,WAAAA,CAAxB,YAAA;AACA,MAAMU,YAAY,GAAGD,eAAe,KAAfA,SAAAA,GAAAA,EAAAA,GAArB,eAAA;AAEA,SAAOD,aAAW,CAAA,WAAA,EAAA,YAAA,EAAlB,SAAkB,CAAlB;AAKA;;SAceP,kB,CAIdD,G,EAAwCW,K,EAAAA;AACzC,MAAMC,aAAa,GAAnB,EAAA;AAGA,MAAMC,gBAAgB,GAAGC,MAAM,CAANA,IAAAA,CAAYH,KAAK,CAA1C,QAAyBG,CAAzB;AACAD,EAAAA,gBAAgB,CAAhBA,OAAAA,CAAyB,UAAA,UAAA,EAAA;AACxB,QAAME,UAAU,GAAGC,mBAAmB,CAAnBA,UAAmB,CAAnBA,GAAAA,UAAAA,GAEbL,KAAK,CAFQK,IAEbL,GAFaK,GAEbL,GAFN,UAAA;AAIAC,IAAAA,aAAa,CAAbA,UAAa,CAAbA,GAA4BD,KAAK,CAALA,QAAAA,CAA5BC,UAA4BD,CAA5BC;AALDC,GAAAA;;AASA,MAAMI,eAAe,GAAG,SAAlBA,eAAkB,CAAA,KAAA,EAAA,MAAA,EAAA;QACvBC,KAAAA,KAAAA,KAAAA,C,EAAAA;AAAAA,MAAAA,KAAAA,GAAgBP,KAAK,CAACO,KAAtBA;;;AAGA,QAAIC,MAAM,CAANA,IAAAA,IAAJ,aAAA,EAAkC;AACjC,aAAOP,aAAa,CAACO,MAAM,CAApBP,IAAa,CAAbA,CAAAA,KAAAA,EAAkCO,MAAM,CAAxCP,OAAAA,EAAkDO,MAAM,CAA/D,IAAOP,CAAP;AACA;;AAED,WAAA,KAAA;AARD,GAAA;;AAWA,MAAMQ,gBAAgB,GAAGT,KAAK,CAA9B,WAAA;AAGA,MAAIU,OAAO,GAAG,CAAA,gBAAA,GAAA,eAAA,GAEX,UAAA,KAAA,EAAA,MAAA,EAAA;AAAA,QAACH,KAAD,KAAA,KAAA,CAAA,EAAA;AAACA,MAAAA,KAAD,GAAiBP,KAAK,CAAtB,KAACO;AAAD;;AAAA,WACAD,eAAe,CAACG,gBAAgB,CAAA,KAAA,EAAjB,MAAiB,CAAjB,EADf,MACe,CADf;AAFH,GAAA;AAKApB,EAAAA,GAAG,CAAHA,aAAAA,CAAAA,WAAAA,EAA+B,UAAA,SAAA,EAAA;AAC9BqB,IAAAA,OAAO,GAAGC,SAAS,CAAA,OAAA,EAAUX,KAAK,CAAf,IAAA,EAATW,GAAS,CAATA,IAAVD,OAAAA;AADDrB,GAAAA;AAIAA,EAAAA,GAAG,CAAHA,WAAAA,CAAAA,QAAAA,CAAyBW,KAAK,CAA9BX,IAAAA,IAAAA,OAAAA;AACA;;SAQeG,iB,CAIdH,G,EAAAA;AACD,MAAQuB,YAAR,GAAyBvB,GAAG,CAA5B,WAAyBA,CAAzB,YAAA;AACA,MAAMwB,cAAc,GAAGC,aAAa,CAAazB,GAAG,CAApD,WAAoC,CAApC;AACA,MAAIE,WAAW,GAAf,cAAA;;AAEA,MAAIqB,YAAY,IAAIT,MAAM,CAANA,IAAAA,CAAAA,YAAAA,EAApB,MAAA,EAAsD;AACrDZ,IAAAA,WAAW,GAAG,SAAA,WAAA,CAAA,KAAA,EAAA,MAAA,EAAA;AAIb,UAAMwB,iBAAiB,GAAGH,YAAY,CAACJ,MAAM,CAA7C,IAAsC,CAAtC;;AAEA,UAAA,iBAAA,EAAuB;AACtB,eAAOK,cAAc,CAACE,iBAAiB,CAAA,KAAA,EAAlB,MAAkB,CAAlB,EAArB,MAAqB,CAArB;AACA;;AAED,aAAOF,cAAc,CAAA,KAAA,EAArB,MAAqB,CAArB;AAVDtB,KAAAA;AAYA;;AAEDF,EAAAA,GAAG,CAAHA,aAAAA,CAAAA,eAAAA,EAAmC,UAAA,aAAA,EAAA;AAClCE,IAAAA,WAAW,GAAGyB,aAAa,CAAA,WAAA,EAAbA,GAAa,CAAbA,IAAdzB,WAAAA;AADDF,GAAAA;AAIA,SAAA,WAAA;AACA;;AAQD,SAAA,aAAA,CAAA,WAAA,EAAA;AAGC,MAAM4B,iBAAe,GAAGC,WAAW,CAAXA,eAAAA,IAAxB,eAAA;;AAEA,MAAI,CAACf,MAAM,CAANA,IAAAA,CAAYe,WAAW,CAAvBf,QAAAA,EAAL,MAAA,EAA+C;AAC9C,WAAO,UAAA,KAAA,EAAA;AAAA,aAAA,KAAA;AAAP,KAAA;AACA;;AAED,SAAOc,iBAAe,CAACC,WAAW,CAAlC,QAAsB,CAAtB;AACA;;AAMD,SAAA,4BAAA,CAAA,cAAA,EAAA;MACCC,cAAAA,KAAAA,KAAAA,C,EAAAA;AAAAA,IAAAA,cAAAA,GAAiC,EAAjCA;;;AAEA,SAAO,CAACA,cAAc,CAAf,QAAA,IACN,OAAA,MAAA,KADM,QAAA,IAENC,MAAM,CAFA,oCAAA,GAGJA,MAAM,CAANA,oCAAAA,CAHI,cAGJA,CAHI,GAAP,OAAA;AAKA;;AAMD,SAAA,mBAAA,CAAA,UAAA,EAAA;AACC,SAAOC,UAAU,CAAVA,OAAAA,CAAAA,GAAAA,IAA0B,CAAjC,CAAA;AACA;;AC3JM,IAAMC,QAAQ,GAAG,SAAXA,QAAW,CAAA,GAAA,EAAA;AAAA,SACvB,OAAA,GAAA,KAAA,QAAA,IAA2BC,GAAG,KAA9B,IAAA,IAA2C,CAACC,KAAK,CAALA,OAAAA,CADrB,GACqBA,CADrB;AAAjB,CAAA;;AAOA,IAAMC,mBAAmB,GAAG,SAAtBA,mBAAsB,CAAA,IAAA,EAAA;AAAA,SAClC,CAAA,IAAA,IAAS,OAAA,IAAA,KADyB,UAAA;AAA5B,CAAA;;AAQP,IAAMC,QAAQ,GAAG,SAAXA,QAAW,CAAA,cAAA,EAAA;AAChB,MAAIC,OAAO,CAAPA,GAAAA,CAAAA,QAAAA,KAAJ,YAAA,EAA2C;AAC1C,QAAMC,WAAW,GAAGC,cAApB,EAAA;AACA,QAAMC,MAAM,GAAZ,EAAA;AAEAF,IAAAA,WAAW,CAAXA,OAAAA,CAAoB,UAAA,UAAA,EAAA;AACnB,UAAMG,SAAS,GAAGC,UAAU,CAA5B,CAA4B,CAA5B;AACA,UAAMC,YAAY,GAAGD,UAAU,CAA/B,CAA+B,CAA/B;;AACA,UAAA,SAAA,EAAe;AACdF,QAAAA,MAAM,CAANA,IAAAA,CAAAA,YAAAA;AACA;AALFF,KAAAA;;AAQA,QAAIE,MAAM,CAANA,MAAAA,GAAJ,CAAA,EAAuB;AACtB,YAAM,IAAA,KAAA,CAAUA,MAAM,CAANA,IAAAA,CAAhB,IAAgBA,CAAV,CAAN;AACA;AACD;AAhBF,CAAA;;AAmBO,IAAMI,cAAc,GAAG,SAAjBA,cAAiB,CAAA,MAAA,EAAA;AAM7BR,EAAAA,QAAQ,CAAC,YAAA;AAAA,WAAM,CACd,CAAC,CAACF,KAAK,CAALA,OAAAA,CAAcW,MAAM,CAAtB,OAAEX,CAAF,EADc,sCACd,CADc,EAEd,CAAC,CAACF,QAAQ,CAACa,MAAM,CAAjB,MAAU,CAAV,EAFc,sCAEd,CAFc,EAGd,CACC,CAACb,QAAQ,CAACa,MAAM,CAANA,KAAAA,CADX,QACU,CADV,EAHc,8CAGd,CAHc,EAOd,CACC,CAACX,KAAK,CAALA,OAAAA,CAAcW,MAAM,CAANA,KAAAA,CADhB,WACEX,CADF,EAPc,gDAOd,CAPc,EAWd,CACC,CAACA,KAAK,CAALA,OAAAA,CAAcW,MAAM,CAANA,KAAAA,CADhB,SACEX,CADF,EAXc,2DAWd,CAXc,EAed,CACC,CAACC,mBAAmB,CAACU,MAAM,CAANA,KAAAA,CADtB,eACqB,CADrB,EAfc,sDAed,CAfc,EAmBd,CACC,CAACV,mBAAmB,CAACU,MAAM,CAANA,KAAAA,CADtB,WACqB,CADrB,EAnBQ,kDAmBR,CAnBc,CAAN;AAATT,GAAQ,CAARA;AANM,CAAA;;AAgCA,IAAMU,aAAa,GAAG,SAAhBA,aAAgB,CAAA,KAAA,EAAA;AAG5BV,EAAAA,QAAQ,CAAC,YAAA;AAAA,WAAM,CACd,CAAC,CAAD,KAAA,EADc,0BACd,CADc,EAEd,CAAC,OAAO1B,KAAK,CAAZ,IAAA,KAAD,QAAA,EAFc,mCAEd,CAFc,EAGd,CACCA,KAAK,CAALA,KAAAA,KAAAA,SAAAA,IAA6BA,KAAK,CAALA,WAAAA,KAD9B,SAAA,EAHc,2BAGd,CAHc,EAOd,CACC,CAACyB,mBAAmB,CAACzB,KAAK,CAD3B,WACqB,CADrB,EAPQ,wCAOR,CAPc,CAAN;AAAT0B,GAAQ,CAARA;AAHM,CAAA;;AAiBA,IAAMW,cAAc,GAAG,SAAjBA,cAAiB,CAAA,MAAA,EAAA;AAM7BX,EAAAA,QAAQ,CAAC,YAAA;AAAA,WAAM,CACd,CACC,CAACD,mBAAmB,CAACa,MAAM,CAD5B,cACqB,CADrB,EADc,0CACd,CADc,EAKd,CAAC,CAACb,mBAAmB,CAACa,MAAM,CAA5B,OAAqB,CAArB,EALc,mCAKd,CALc,EAMd,CACC,CAACb,mBAAmB,CAACa,MAAM,CAD5B,SACqB,CADrB,EANc,qCAMd,CANc,EAUd,CACC,CAACb,mBAAmB,CAACa,MAAM,CAD5B,aACqB,CADrB,EAVc,yCAUd,CAVc,EAcd,CACC,CAACb,mBAAmB,CAACa,MAAM,CAD5B,gBACqB,CADrB,EAdQ,4CAcR,CAdc,CAAN;AAATZ,GAAQ,CAARA;AANM,CAAA;;AA2BA,IAAMa,oBAAoB,GAAG,SAAvBA,oBAAuB,CAAA,SAAA,EAAA,QAAA,EAAA,WAAA,EAAA;AAKnCb,EAAAA,QAAQ,CAAC,YAAA;AAAA,WAAM,CACd,CACC,CAAC,CAACc,WAAW,CAAXA,KAAAA,CADH,QACGA,CADH,EAAA,2BAAA,SAAA,GAAA,GAAA,GAAA,WAAA,GADc,GACd,CADc,EAKd,CACC,OAAOC,QAAQ,CAAf,WAAe,CAAf,KADD,UAAA,EAAA,sBAAA,SAAA,GAAA,GAAA,GAAA,WAAA,GALQ,uBAKR,CALc,CAAN;AAATf,GAAQ,CAARA;AALM,CAAA;;AAiBA,IAAMgB,mBAAmB,GAAG,SAAtBA,mBAAsB,CAAA,SAAA,EAAA,OAAA,EAAA,UAAA,EAAA;AAKlChB,EAAAA,QAAQ,CAAC,YAAA;AAAA,WAAM,CACd,CACC,CAAC,CAACiB,UAAU,CAAVA,KAAAA,CADH,IACGA,CADH,EAAA,0BAAA,SAAA,GAAA,GAAA,GAAA,UAAA,GADc,GACd,CADc,EAKd,CACC,OAAOC,OAAO,CAAd,UAAc,CAAd,KADD,UAAA,EAAA,qBAAA,SAAA,GAAA,GAAA,GAAA,UAAA,GALQ,uBAKR,CALc,CAAN;AAATlB,GAAQ,CAARA;AALM,CAAA;;AC9HP,IAAMmB,sBAAsB,GAAG,SAAzBA,sBAAyB,CAAA,OAAA,EAAA,SAAA,EAAA,UAAA,EAAA,QAAA,EAAA;AAS9B,SAAO,MAAM,CAAN,MAAA,CACN,UAAA,OAAA,EAAA,IAAA,EAAA;AACC,QAAMrC,MAAM,GAAW;AAAEsC,MAAAA,IAAI,EAAKC,SAAL,GAAA,GAAKA,GAAa3C;AAAxB,KAAvB;;AAEA,QAAI,OAAA,OAAA,KAAJ,WAAA,EAAoC;AACnCI,MAAAA,MAAM,CAANA,OAAAA,GAAAA,OAAAA;AACA;;AAED,QAAI,OAAA,IAAA,KAAJ,WAAA,EAAiC;AAChCA,MAAAA,MAAM,CAANA,IAAAA,GAAAA,IAAAA;AACA;;AAED,WAAOwC,OAAO,CAAPA,QAAAA,CAAP,MAAOA,CAAP;AAZK,GAAA,EAcN;AACCC,IAAAA,QAAQ,EAARA;AADD,GAdM,CAAP;AATD,CAAA;;AAkCA,IAAMC,gBAAgB,GAAG,SAAnBA,gBAAmB,CAAA,OAAA,EAAA,GAAA,EAAA,KAAA,EAAA;AASxB,MAAMC,eAAe,GAAGH,OAAO,CAAPA,QAAAA,CAAiBhD,KAAK,CAA9C,IAAwBgD,CAAxB;AAGA,MAAMI,iBAAiB,GAAGjD,MAAM,CAANA,IAAAA,CAAYH,KAAK,CAA3C,QAA0BG,CAA1B;AACAiD,EAAAA,iBAAiB,CAAjBA,OAAAA,CAA0B,UAAA,WAAA,EAAA;AACzBb,IAAAA,oBAAoB,CAACvC,KAAK,CAAN,IAAA,EAAaA,KAAK,CAAlB,QAAA,EAApBuC,WAAoB,CAApBA;AAEAY,IAAAA,eAAe,CAAfA,WAAe,CAAfA,GAA+BN,sBAAsB,CAAA,OAAA,EAEpD7C,KAAK,CAF+C,IAAA,EAAA,WAAA,EAArDmD,KAAqD,CAArDA;AAHDC,GAAAA;AAWA,MAAIR,OAAO,GAAX,EAAA;;AAGA,MAAI5C,KAAK,CAAT,OAAA,EAAmB;AAClB4C,IAAAA,OAAO,GACN,OAAO5C,KAAK,CAAZ,OAAA,KAAA,UAAA,GACIA,KAAK,CAALA,OAAAA,CAA+CgD,OAAO,CAD1D,QACIhD,CADJ,GAEGA,KAAK,CAHT4C,OAAAA;AAIA;;AAGD,MAAMS,UAAU,GAAGlD,MAAM,CAANA,IAAAA,CAAnB,OAAmBA,CAAnB;AACAkD,EAAAA,UAAU,CAAVA,OAAAA,CAAmB,UAAA,UAAA,EAAA;AAClBX,IAAAA,mBAAmB,CAAC1C,KAAK,CAAN,IAAA,EAAA,OAAA,EAAnB0C,UAAmB,CAAnBA;AAEArD,IAAAA,GAAG,CAAHA,OAAAA,CAAeW,KAAK,CAApBX,IAAeW,GAAfX,GAAeW,GAAfX,UAAAA,IAA6CuD,OAAO,CAAPA,UAAO,CAAPA,CAAAA,IAAAA,CAA7CvD,eAA6CuD,CAA7CvD;AAIA8D,IAAAA,eAAe,CAAfA,UAAe,CAAfA,GAA8BN,sBAAsB,CAAA,OAAA,EAEnD7C,KAAK,CAF8C,IAAA,EAAA,UAAA,EAApDmD,IAAoD,CAApDA;AAPDE,GAAAA;AApCD,CAAA;;SC9CwBC,gB,CAGtBnB,M,EAAAA;AACD,SAAO;AACNoB,IAAAA,MAAM,EAAEC,iBAAiB,CAACrB,MAAM,CAD1B,MACmB,CADnB;AAENjB,IAAAA,WAAW,EAAEiB,MAAM,CAFb,KAAA;AAGNsB,IAAAA,aAHM,EAAA,SAAA,aAAA,CAAA,MAAA,EAAA,EAAA,EAAA;AAILtB,MAAAA,MAAM,CAANA,OAAAA,CAAAA,OAAAA,CAAuB,UAAA,MAAA,EAAA;AACtB,YAAIG,MAAM,CAAV,MAAU,CAAV,EAAoB;AACnBoB,UAAAA,EAAE,CAACpB,MAAM,CAAToB,MAAS,CAAP,CAAFA;AACA;AAHFvB,OAAAA;AAJK,KAAA;AAUNS,IAAAA,OAAO,EAAE;AAVH,GAAP;AAYA;;AAOD,SAAA,iBAAA,CAAA,MAAA,EAAA;AAGC,SAAO,MAAM,CAAN,IAAA,CAAA,MAAA,EAAA,GAAA,CAAwB,UAAA,SAAA,EAAA;AAC9B,QAAM5C,KAAK,GAAG2D,gBAAgB,CAAA,SAAA,EAAaJ,MAAkB,CAA7D,SAA6D,CAA/B,CAA9B;AACAnB,IAAAA,aAAa,CAAbA,KAAa,CAAbA;AACA,WAAA,KAAA;AAHD,GAAO,CAAP;AAKA;;AAMD,SAAA,gBAAA,CAAA,IAAA,EAAA,KAAA,EAAA;AAIC,SAAA,QAAA,CAAA;AACCwB,IAAAA,IAAI,EADL,IAAA;AAECnB,IAAAA,QAAQ,EAAE;AAFX,GAAA,EAAA,KAAA,CAAA;AAKA;;SC/BuBoB,kB,CAGtB1B,M,EAAAA;AAED,MAAM9C,GAAG,GAAGiE,gBAAgB,CAA5B,MAA4B,CAA5B;AAGAjE,EAAAA,GAAG,CAAHA,WAAAA,CAAAA,WAAAA,CAAAA,IAAAA,CAAiCyE,uBAAuB,CAAxDzE,GAAwD,CAAxDA;AAGAA,EAAAA,GAAG,CAAHA,aAAAA,CAAAA,kBAAAA,EAAsC,UAAA,gBAAA,EAAA;AACrCA,IAAAA,GAAG,CAAHA,WAAAA,CAAAA,WAAAA,CAAAA,IAAAA,CAAiC0E,gBAAgB,CAAjD1E,GAAiD,CAAjDA;AADDA,GAAAA;AAIA,MAAM2E,UAAU,GAAG5E,gBAAgB,CAAnC,GAAmC,CAAnC;;AAEA,MAAI6E,YAAY,GAAA,QAAA,CAAA,EAAA,EAAA,UAAA,EAAA;AAEfL,IAAAA,IAAI,EAAEzB,MAAM,CAFG,IAAA;AAGf+B,IAAAA,QAHe,EAAA,SAAA,QAAA,CAAA,KAAA,EAAA;AAId9B,MAAAA,aAAa,CAAbA,KAAa,CAAbA;AACA9C,MAAAA,kBAAkB,CAAA,GAAA,EAAlBA,KAAkB,CAAlBA;AACA6E,MAAAA,YAAY,CAAA,YAAA,EAAA,GAAA,EAAZA,KAAY,CAAZA;AACAH,MAAAA,UAAU,CAAVA,cAAAA,CAA0BxE,iBAAiB,CAA3CwE,GAA2C,CAA3CA;AACAA,MAAAA,UAAU,CAAVA,QAAAA,CAAoB;AAAElB,QAAAA,IAAI,EAAE;AAAR,OAApBkB;AACA;AATc,GAAA,CAAhB;;AAYAI,EAAAA,UAAU,CAAA,YAAA,EAAejC,MAAM,CAA/BiC,OAAU,CAAVA;AAGA/E,EAAAA,GAAG,CAAHA,MAAAA,CAAAA,OAAAA,CAAmB,UAAA,KAAA,EAAA;AAAA,WAAW8E,YAAY,CAAA,YAAA,EAAA,GAAA,EAAvB,KAAuB,CAAvB;AAAnB9E,GAAAA;AAEAA,EAAAA,GAAG,CAAHA,aAAAA,CAAAA,gBAAAA,EAAoC,UAAA,cAAA,EAAA;AACnC4E,IAAAA,YAAY,GAAGI,cAAc,CAAA,YAAA,EAAdA,GAAc,CAAdA,IAAfJ,YAAAA;AADD5E,GAAAA;AAIA,SAAA,YAAA;AACA;;AAED,SAAA,uBAAA,CAAA,GAAA,EAAA;AAIC,SAAO,UAAA,KAAA,EAAA;AAAA,WAAW,UAAA,IAAA,EAAA;AAAA,aAAU,UAAA,MAAA,EAAA;AAC3B,YAAImB,MAAM,CAANA,IAAAA,IAAenB,GAAG,CAAtB,OAAA,EAAgC;AAE/BiF,UAAAA,IAAI,CAAJA,MAAI,CAAJA;AAGA,iBAAQjF,GAAG,CAAHA,OAAAA,CAAoBmB,MAAM,CAA1BnB,IAAAA,EACPmB,MAAM,CADCnB,OAAAA,EAEPkF,KAAK,CAFElF,QAEPkF,EAFOlF,EAGPmB,MAAM,CAHP,IAAQnB,CAAR;AAKA;;AAED,eAAOiF,IAAI,CAAX,MAAW,CAAX;AAbiB,OAAA;AAAX,KAAA;AAAP,GAAA;AAeA;;AAED,SAAA,YAAA,CAAA,YAAA,EAAA,GAAA,EAAA,KAAA,EAAA;AASC,MAAMnB,eAAe,GAArB,EAAA;AAGAc,EAAAA,YAAY,CAAZA,QAAAA,CAAAA,KACIjE,KAAK,CADTiE,IAAAA,IAAAA,eAAAA;AAIAf,EAAAA,gBAAgB,CAAA,YAAA,EAAA,GAAA,EAAhBA,KAAgB,CAAhBA;AAEA7D,EAAAA,GAAG,CAAHA,aAAAA,CAAAA,SAAAA,EAA6B,UAAA,OAAA,EAAA;AAC5BmF,IAAAA,OAAO,CAAA,KAAA,EAAPA,YAAO,CAAPA;AADDnF,GAAAA;AAGA;;AASD,SAAA,UAAA,CAAA,KAAA,EAAA,OAAA,EAAA;AAOCoF,EAAAA,OAAO,CAAPA,OAAAA,CAAgB,UAAA,MAAA,EAAA;AACf,QAAI,CAACnC,MAAM,CAAX,OAAA,EAAqB;AACrB,QAAMoC,UAAU,GAAGvE,MAAM,CAANA,IAAAA,CAAYmC,MAAM,CAArC,OAAmBnC,CAAnB;AACAuE,IAAAA,UAAU,CAAVA,OAAAA,CAAmB,UAAA,GAAA,EAAA;AAClB,UAAI,CAACpC,MAAM,CAAX,OAAA,EAAqB;AACrB,UAAMqC,WAAW,GAAGrC,MAAM,CAANA,OAAAA,CAApB,GAAoBA,CAApB;AAGA,UAAMsC,iBAAiB,GAAG,OAAA,WAAA,KAA1B,UAAA;AAEAL,MAAAA,KAAK,CAALA,GAAK,CAALA,GAAaK,iBAAiB,GAC3B,YAAA;AAAA,aAAA,IAAA,IAAA,GAAA,SAAA,CAAA,MAAA,EAAIC,MAAJ,GAAA,IAAA,KAAA,CAAA,IAAA,CAAA,EAAA,IAAA,GAAA,CAAA,EAAA,IAAA,GAAA,IAAA,EAAA,IAAA,EAAA,EAAA;AAAIA,UAAAA,MAAJ,CAAA,IAAA,CAAIA,GAAJ,SAAA,CAAA,IAAA,CAAIA;AAAJ;;AAAA,eACCF,WAAsD,CAAtDA,KAAAA,CAAAA,KAAAA,CAAAA,EAAAA,CAAAA,KAAAA,EAAAA,MAAAA,CADD,MACCA,CAAAA,CADD;AAD2B,OAAA,GAM3BxE,MAAM,CAANA,MAAAA,CAAcmC,MAAM,CAANA,OAAAA,CANjBiC,GAMiBjC,CAAdnC,CANHoE;AAPDG,KAAAA;AAHDD,GAAAA;AAmBA;;ACzID,IAAIK,KAAK,GAAT,CAAA;;AAOA,SAAwBC,YAAxB,CAICC,UAJD,EAICA;;;AAEA,MAAMC,SAAS,GAAA,CAAA,gBAAA,GAAGD,UAAU,CAAb,IAAA,KAAA,IAAA,GAAA,gBAAA,GAAA,mBAAf,KAAA;AAEAF,EAAAA,KAAK,IAALA,CAAAA;AAEA,MAAM3C,MAAM,GAAG;AACdyB,IAAAA,IAAI,EADU,SAAA;AAEdL,IAAAA,MAAM,EAAEyB,UAAU,CAAVA,MAAAA,IAFM,EAAA;AAGdP,IAAAA,OAAO,EAAEO,UAAU,CAAVA,OAAAA,IAHK,EAAA;AAIdE,IAAAA,KAAK,EAAA,QAAA,CAAA;AACJzC,MAAAA,QAAQ,EADJ,EAAA;AAEJ7B,MAAAA,YAAY,EAFR,EAAA;AAGJjB,MAAAA,SAAS,EAHL,EAAA;AAIJF,MAAAA,WAAW,EAAE;AAJT,KAAA,EAKDuF,UAAU,CALT,KAAA,EAAA;AAMJ7D,MAAAA,cAAc,EAAA,QAAA,CAAA;AACbyC,QAAAA,IAAI,EAAEqB;AADO,OAAA,EAAA,CAAA,qBAAA,GAAA,CAAA,iBAAA,GAETD,UAAU,CAFD,KAAA,KAAA,IAAA,GAAA,KAAA,CAAA,GAETA,iBAAAA,CAFS,cAAA,KAAA,IAAA,GAAA,qBAAA,GAAA,EAAA;AANV,KAAA;AAJS,GAAf;AAiBA9C,EAAAA,cAAc,CAAdA,MAAc,CAAdA;AAGAC,EAAAA,MAAM,CAANA,OAAAA,CAAAA,OAAAA,CAAuB,UAAA,MAAA,EAAA;AACtB,QAAIG,MAAM,CAAV,MAAA,EAAmB;AAElBH,MAAAA,MAAM,CAANA,MAAAA,GAAgBgD,KAAK,CAAChD,MAAM,CAAP,MAAA,EAAgBG,MAAM,CAANA,MAAAA,CAArCH,MAAqB,CAArBA;;AAGA,UAAIG,MAAM,CAANA,MAAAA,CAAJ,KAAA,EAAyB;AACxBH,QAAAA,MAAM,CAANA,KAAAA,CAAAA,YAAAA,GAA4BgD,KAAK,CAChChD,MAAM,CAANA,KAAAA,CADgC,YAAA,EAEhCG,MAAM,CAANA,MAAAA,CAAAA,KAAAA,CAFDH,YAAiC,CAAjCA;AAKAA,QAAAA,MAAM,CAANA,KAAAA,CAAAA,QAAAA,GAAwBgD,KAAK,CAC5BhD,MAAM,CAANA,KAAAA,CAD4B,QAAA,EAE5BG,MAAM,CAANA,MAAAA,CAAAA,KAAAA,CAFDH,QAA6B,CAA7BA;AAKAA,QAAAA,MAAM,CAANA,KAAAA,CAAAA,YAAAA,GAA4BgD,KAAK,CAChChD,MAAM,CAANA,KAAAA,CADgC,YAAA,EAEhCG,MAAM,CAANA,MAAAA,CAAAA,KAAAA,CAFDH,QAAiC,CAAjCA;AAKAA,QAAAA,MAAM,CAANA,KAAAA,CAAAA,SAAAA,GAAAA,GAAAA,MAAAA,CACIA,MAAM,CAANA,KAAAA,CADJA,SAAAA,EAEKG,MAAM,CAANA,MAAAA,CAAAA,KAAAA,CAAAA,SAAAA,IAFLH,EAAAA,CAAAA;AAKAA,QAAAA,MAAM,CAANA,KAAAA,CAAAA,WAAAA,GAAAA,GAAAA,MAAAA,CACIA,MAAM,CAANA,KAAAA,CADJA,WAAAA,EAEKG,MAAM,CAANA,MAAAA,CAAAA,KAAAA,CAAAA,WAAAA,IAFLH,EAAAA,CAAAA;AAKAA,QAAAA,MAAM,CAANA,KAAAA,CAAAA,eAAAA,GACCA,MAAM,CAANA,KAAAA,CAAAA,eAAAA,IAAgCG,MAAM,CAANA,MAAAA,CAAAA,KAAAA,CADjCH,eAAAA;AAGAA,QAAAA,MAAM,CAANA,KAAAA,CAAAA,WAAAA,GACCA,MAAM,CAANA,KAAAA,CAAAA,WAAAA,IAA4BG,MAAM,CAANA,MAAAA,CAAAA,KAAAA,CAD7BH,WAAAA;AAEA;AACD;;AAEDE,IAAAA,cAAc,CAAdA,MAAc,CAAdA;AAxCDF,GAAAA;AA2CA,SAAA,MAAA;AACA;;AAMD,SAAA,KAAA,CAAA,QAAA,EAAA,KAAA,EAAA;AAIC,SAAOiD,KAAK,GAAA,QAAA,CAAA,EAAA,EAAA,KAAA,EAAA,QAAA,CAAA,GAAZ,QAAA;AACA;;ICxFYC,IAAI,GAAG,SAAPA,IAAO,CAAA,UAAA,EAAA;AAMnB,MAAMlD,MAAM,GAAG4C,YAAY,CAACC,UAAU,IAAtC,EAA2B,CAA3B;AACA,SAAOnB,kBAAkB,CAAzB,MAAyB,CAAzB;AAPM,C;;AAUP,IAAayB,WAAW,GAAiB,SAA5BA,WAA4B,GAAA;AAAA,SAAM,UAAA,EAAA,EAAA;AAC9C,QAAA,YAAA,GAAwCC,EAAxC,CAAA,QAAA;AAAA,QAAQ9C,QAAR,GAAA,YAAA,KAAA,KAAA,CAAA,GAAA,EAAA,GAAA,YAAA;AAAA,QAAA,WAAA,GAAwC8C,EAAxC,CAAA,OAAA;AAAA,QAAuB3C,OAAvB,GAAA,WAAA,KAAA,KAAA,CAAA,GAAA,EAAA,GAAA,WAAA;AAEA,WAAA,QAAA,CAAA,EAAA,EAAA,EAAA,EAAA;AAECH,MAAAA,QAAQ,EAFT,QAAA;AAGCG,MAAAA,OAAO,EAAPA;AAHD,KAAA,CAAA;AAHwC,GAAA;AAAlC,CAAP;;AAUA,IAAA,KAAA,GAAe;AACdyC,EAAAA,IAAI,EADU,IAAA;AAEdC,EAAAA,WAAW,EAAXA;AAFc,CAAf","sourcesContent":["import * as Redux from 'redux'\nimport {\n\tAction,\n\tConfigRedux,\n\tModelReducers,\n\tNamedModel,\n\tRematchBag,\n\tDevtoolOptions,\n\tModels,\n\tRematchRootState,\n} from './types'\n\n/**\n * Creates 'combined' reducer for each model and then merges those reducers\n * together into a 'root' reducer. It then creates a Redux store with\n * middlewares and enhancers.\n */\nexport default function createReduxStore<\n\tTModels extends Models<TModels>,\n\tTExtraModels extends Models<TModels>,\n\tRootState = RematchRootState<TModels, TExtraModels>\n>(bag: RematchBag<TModels, TExtraModels>): Redux.Store<RootState> {\n\tbag.models.forEach((model) => createModelReducer(bag, model))\n\n\tconst rootReducer = createRootReducer<RootState, TModels, TExtraModels>(bag)\n\n\tconst middlewares = Redux.applyMiddleware(...bag.reduxConfig.middlewares)\n\tconst enhancers = composeEnhancersWithDevtools(\n\t\tbag.reduxConfig.devtoolOptions\n\t)(...bag.reduxConfig.enhancers, middlewares)\n\n\tconst createStore = bag.reduxConfig.createStore || Redux.createStore\n\tconst bagInitialState = bag.reduxConfig.initialState\n\tconst initialState = bagInitialState === undefined ? {} : bagInitialState\n\n\treturn createStore<RootState, Action, any, typeof initialState>(\n\t\trootReducer,\n\t\tinitialState,\n\t\tenhancers\n\t)\n}\n\n/**\n * Creates a combined reducer for a given model. What it means is that:\n * - it forms an action name for each model's reducer as 'modelName/reducerKey'\n * - it creates a mapping from action name to its reducer\n * - it wraps the mapping with a function (combined reducer) that selects and\n *   runs a reducer based on the incoming action\n * - if the model also has a base reducer defined, it creates a function which\n *   first runs the incoming action through this reducer and then passes the\n *   resulting state and the same action to combined reducer\n *\n * The final result - a function, is returned.\n */\nexport function createModelReducer<\n\tTModels extends Models<TModels>,\n\tTExtraModels extends Models<TModels>,\n\tTState extends NamedModel<TModels>['state'] = any\n>(bag: RematchBag<TModels, TExtraModels>, model: NamedModel<TModels>): void {\n\tconst modelReducers: ModelReducers<TState> = {}\n\n\t// build action name for each reducer and create mapping from name to reducer\n\tconst modelReducerKeys = Object.keys(model.reducers)\n\tmodelReducerKeys.forEach((reducerKey) => {\n\t\tconst actionName = isAlreadyActionName(reducerKey)\n\t\t\t? reducerKey\n\t\t\t: `${model.name}/${reducerKey}`\n\n\t\tmodelReducers[actionName] = model.reducers[reducerKey]\n\t})\n\n\t// select and run a reducer based on the incoming action\n\tconst combinedReducer = (\n\t\tstate: TState = model.state,\n\t\taction: Action\n\t): TState => {\n\t\tif (action.type in modelReducers) {\n\t\t\treturn modelReducers[action.type](state, action.payload, action.meta)\n\t\t}\n\n\t\treturn state\n\t}\n\n\tconst modelBaseReducer = model.baseReducer\n\n\t// when baseReducer is defined, run the action first through it\n\tlet reducer = !modelBaseReducer\n\t\t? combinedReducer\n\t\t: (state: TState = model.state, action: Action): TState =>\n\t\t\t\tcombinedReducer(modelBaseReducer(state, action), action)\n\n\tbag.forEachPlugin('onReducer', (onReducer) => {\n\t\treducer = onReducer(reducer, model.name, bag) || reducer\n\t})\n\n\tbag.reduxConfig.reducers[model.name] = reducer\n}\n\n/**\n * It merges all reducers in config using mergeReducers function. Additionally,\n * if user supplied any rootReducers, a wrapper function around merged reducers\n * is created. It first feeds each into its corresponding 'root' reducer (if\n * it's available), and then passes on the resulting state to the merged reducer.\n */\nexport function createRootReducer<\n\tTRootState,\n\tTModels extends Models<TModels>,\n\tTExtraModels extends Models<TModels>\n>(bag: RematchBag<TModels, TExtraModels>): Redux.Reducer<TRootState, Action> {\n\tconst { rootReducers } = bag.reduxConfig\n\tconst mergedReducers = mergeReducers<TRootState>(bag.reduxConfig)\n\tlet rootReducer = mergedReducers\n\n\tif (rootReducers && Object.keys(rootReducers).length) {\n\t\trootReducer = (\n\t\t\tstate: TRootState | undefined,\n\t\t\taction: Action\n\t\t): TRootState => {\n\t\t\tconst actionRootReducer = rootReducers[action.type]\n\n\t\t\tif (actionRootReducer) {\n\t\t\t\treturn mergedReducers(actionRootReducer(state, action), action)\n\t\t\t}\n\n\t\t\treturn mergedReducers(state, action)\n\t\t}\n\t}\n\n\tbag.forEachPlugin('onRootReducer', (onRootReducer) => {\n\t\trootReducer = onRootReducer(rootReducer, bag) || rootReducer\n\t})\n\n\treturn rootReducer\n}\n\n/**\n * Merges all reducers defined in config into one function using user supplied\n * or default combineReducers function.\n * If there are no reducers defined, it returns a function that just returns\n * the state for all incoming actions.\n */\nfunction mergeReducers<TRootState>(\n\treduxConfig: ConfigRedux<TRootState>\n): Redux.Reducer<TRootState, Action> {\n\tconst combineReducers = reduxConfig.combineReducers || Redux.combineReducers\n\n\tif (!Object.keys(reduxConfig.reducers).length) {\n\t\treturn (state: any): TRootState => state\n\t}\n\n\treturn combineReducers(reduxConfig.reducers as Redux.ReducersMapObject)\n}\n\n/**\n * Returns Redux Devtools compose method unless it's disabled, in which case it\n * returns default Redux.compose.\n */\nfunction composeEnhancersWithDevtools(\n\tdevtoolOptions: DevtoolOptions = {}\n): (...args: any[]) => Redux.StoreEnhancer {\n\treturn !devtoolOptions.disabled &&\n\t\ttypeof window === 'object' &&\n\t\twindow.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__\n\t\t? window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__(devtoolOptions)\n\t\t: Redux.compose\n}\n\n/**\n * Determines if a reducer key is already an action name, for example -\n * a listener on another model.\n */\nfunction isAlreadyActionName(reducerKey: string): boolean {\n\treturn reducerKey.indexOf('/') > -1\n}\n","import {\n\tConfig,\n\tModelEffects,\n\tModelReducers,\n\tNamedModel,\n\tPlugin,\n\tModels,\n} from './types'\n\n/**\n * If the first item is true, it means there is an error described by\n * the second item.\n */\nexport type Validation = [boolean | undefined, string]\n\n/**\n * Checks if a parameter is a valid object.\n */\nexport const isObject = <T>(obj: T): boolean =>\n\ttypeof obj === 'object' && obj !== null && !Array.isArray(obj)\n\n/**\n * Checks if a parameter is a valid function but only when it's defined.\n * Otherwise, always returns true.\n */\nexport const ifDefinedIsFunction = <T>(func: T): boolean =>\n\t!func || typeof func === 'function'\n\n/**\n * Takes an array of arrays of validations. Collects all errors and throws.\n * Should be used by plugins to keep the validation behaviour the same for all\n * Rematch-related libraries.\n */\nconst validate = (runValidations: () => Validation[]): void => {\n\tif (process.env.NODE_ENV !== 'production') {\n\t\tconst validations = runValidations()\n\t\tconst errors: string[] = []\n\n\t\tvalidations.forEach((validation) => {\n\t\t\tconst isInvalid = validation[0]\n\t\t\tconst errorMessage = validation[1]\n\t\t\tif (isInvalid) {\n\t\t\t\terrors.push(errorMessage)\n\t\t\t}\n\t\t})\n\n\t\tif (errors.length > 0) {\n\t\t\tthrow new Error(errors.join(', '))\n\t\t}\n\t}\n}\n\nexport const validateConfig = <\n\tTModels extends Models<TModels>,\n\tTExtraModels extends Models<TModels>\n>(\n\tconfig: Config<TModels, TExtraModels>\n): void => {\n\tvalidate(() => [\n\t\t[!Array.isArray(config.plugins), 'init config.plugins must be an array'],\n\t\t[!isObject(config.models), 'init config.models must be an object'],\n\t\t[\n\t\t\t!isObject(config.redux.reducers),\n\t\t\t'init config.redux.reducers must be an object',\n\t\t],\n\t\t[\n\t\t\t!Array.isArray(config.redux.middlewares),\n\t\t\t'init config.redux.middlewares must be an array',\n\t\t],\n\t\t[\n\t\t\t!Array.isArray(config.redux.enhancers),\n\t\t\t'init config.redux.enhancers must be an array of functions',\n\t\t],\n\t\t[\n\t\t\t!ifDefinedIsFunction(config.redux.combineReducers),\n\t\t\t'init config.redux.combineReducers must be a function',\n\t\t],\n\t\t[\n\t\t\t!ifDefinedIsFunction(config.redux.createStore),\n\t\t\t'init config.redux.createStore must be a function',\n\t\t],\n\t])\n}\n\nexport const validateModel = <TModels extends Models<TModels>>(\n\tmodel: NamedModel<TModels>\n): void => {\n\tvalidate(() => [\n\t\t[!model, 'model config is required'],\n\t\t[typeof model.name !== 'string', 'model \"name\" [string] is required'],\n\t\t[\n\t\t\tmodel.state === undefined && model.baseReducer === undefined,\n\t\t\t'model \"state\" is required',\n\t\t],\n\t\t[\n\t\t\t!ifDefinedIsFunction(model.baseReducer),\n\t\t\t'model \"baseReducer\" must be a function',\n\t\t],\n\t])\n}\n\nexport const validatePlugin = <\n\tTModels extends Models<TModels>,\n\tTExtraModels extends Models<TModels>\n>(\n\tplugin: Plugin<TModels, TExtraModels>\n): void => {\n\tvalidate(() => [\n\t\t[\n\t\t\t!ifDefinedIsFunction(plugin.onStoreCreated),\n\t\t\t'Plugin onStoreCreated must be a function',\n\t\t],\n\t\t[!ifDefinedIsFunction(plugin.onModel), 'Plugin onModel must be a function'],\n\t\t[\n\t\t\t!ifDefinedIsFunction(plugin.onReducer),\n\t\t\t'Plugin onReducer must be a function',\n\t\t],\n\t\t[\n\t\t\t!ifDefinedIsFunction(plugin.onRootReducer),\n\t\t\t'Plugin onRootReducer must be a function',\n\t\t],\n\t\t[\n\t\t\t!ifDefinedIsFunction(plugin.createMiddleware),\n\t\t\t'Plugin createMiddleware must be a function',\n\t\t],\n\t])\n}\n\nexport const validateModelReducer = (\n\tmodelName: string,\n\treducers: ModelReducers,\n\treducerName: string\n): void => {\n\tvalidate(() => [\n\t\t[\n\t\t\t!!reducerName.match(/\\/.+\\//),\n\t\t\t`Invalid reducer name (${modelName}/${reducerName})`,\n\t\t],\n\t\t[\n\t\t\ttypeof reducers[reducerName] !== 'function',\n\t\t\t`Invalid reducer (${modelName}/${reducerName}). Must be a function`,\n\t\t],\n\t])\n}\n\nexport const validateModelEffect = <TModels extends Models<TModels>>(\n\tmodelName: string,\n\teffects: ModelEffects<TModels>,\n\teffectName: string\n): void => {\n\tvalidate(() => [\n\t\t[\n\t\t\t!!effectName.match(/\\//),\n\t\t\t`Invalid effect name (${modelName}/${effectName})`,\n\t\t],\n\t\t[\n\t\t\ttypeof effects[effectName] !== 'function',\n\t\t\t`Invalid effect (${modelName}/${effectName}). Must be a function`,\n\t\t],\n\t])\n}\n\nexport default validate\n","import {\n\tAction,\n\tModelEffects,\n\tModelEffectsCreator,\n\tModels,\n\tNamedModel,\n\tRematchBag,\n\tRematchDispatcher,\n\tEffectRematchDispatcher,\n\tRematchStore,\n} from './types'\nimport { validateModelEffect, validateModelReducer } from './validate'\n\n/**\n * Builds a dispatcher for given model name and action name. The dispatched\n * action will have a type `modelName/actionName`.\n * Additionally, adds the isEffect property to the created dispatcher.\n * isEffect helps to differentiate effects dispatchers from reducer dispatchers.\n */\nconst createActionDispatcher = <\n\tTModels extends Models<TModels>,\n\tTExtraModels extends Models<TModels>\n>(\n\trematch: RematchStore<TModels, TExtraModels>,\n\tmodelName: string,\n\tactionName: string,\n\tisEffect: boolean\n): RematchDispatcher | EffectRematchDispatcher => {\n\treturn Object.assign(\n\t\t(payload?: any, meta?: any): Action => {\n\t\t\tconst action: Action = { type: `${modelName}/${actionName}` }\n\n\t\t\tif (typeof payload !== 'undefined') {\n\t\t\t\taction.payload = payload\n\t\t\t}\n\n\t\t\tif (typeof meta !== 'undefined') {\n\t\t\t\taction.meta = meta\n\t\t\t}\n\n\t\t\treturn rematch.dispatch(action)\n\t\t},\n\t\t{\n\t\t\tisEffect,\n\t\t}\n\t)\n}\n\n/**\n * Creates a dispatcher object for a model - it contains a mapping from all\n * reducers and effects *names* to functions which dispatch their corresponding\n * actions.\n */\nconst createDispatcher = <\n\tTModels extends Models<TModels>,\n\tTExtraModels extends Models<TModels>,\n\tTModel extends NamedModel<TModels>\n>(\n\trematch: RematchStore<TModels, TExtraModels>,\n\tbag: RematchBag<TModels, TExtraModels>,\n\tmodel: TModel\n): void => {\n\tconst modelDispatcher = rematch.dispatch[model.name]\n\n\t// map reducer names to dispatch actions\n\tconst modelReducersKeys = Object.keys(model.reducers)\n\tmodelReducersKeys.forEach((reducerName) => {\n\t\tvalidateModelReducer(model.name, model.reducers, reducerName)\n\n\t\tmodelDispatcher[reducerName] = createActionDispatcher(\n\t\t\trematch,\n\t\t\tmodel.name,\n\t\t\treducerName,\n\t\t\tfalse\n\t\t)\n\t})\n\n\tlet effects: ModelEffects<TModels> = {}\n\n\t// 'effects' might be actually a function creating effects\n\tif (model.effects) {\n\t\teffects =\n\t\t\ttypeof model.effects === 'function'\n\t\t\t\t? (model.effects as ModelEffectsCreator<TModels>)(rematch.dispatch)\n\t\t\t\t: model.effects\n\t}\n\n\t// map effects names to dispatch actions\n\tconst effectKeys = Object.keys(effects)\n\teffectKeys.forEach((effectName) => {\n\t\tvalidateModelEffect(model.name, effects, effectName)\n\n\t\tbag.effects[`${model.name}/${effectName}`] = effects[effectName].bind(\n\t\t\tmodelDispatcher\n\t\t)\n\n\t\tmodelDispatcher[effectName] = createActionDispatcher(\n\t\t\trematch,\n\t\t\tmodel.name,\n\t\t\teffectName,\n\t\t\ttrue\n\t\t)\n\t})\n}\n\nexport default createDispatcher\n","import { Config, Model, Models, NamedModel, RematchBag } from './types'\nimport { validateModel } from './validate'\n\n/**\n * Creates and returns a 'Rematch Bag', which is a set of configuration options\n * used by the Rematch library in various functions.\n */\nexport default function createRematchBag<\n\tTModels extends Models<TModels>,\n\tTExtraModels extends Models<TModels>\n>(config: Config<TModels, TExtraModels>): RematchBag<TModels, TExtraModels> {\n\treturn {\n\t\tmodels: createNamedModels(config.models),\n\t\treduxConfig: config.redux,\n\t\tforEachPlugin(method, fn): void {\n\t\t\tconfig.plugins.forEach((plugin) => {\n\t\t\t\tif (plugin[method]) {\n\t\t\t\t\tfn(plugin[method]!)\n\t\t\t\t}\n\t\t\t})\n\t\t},\n\t\teffects: {},\n\t}\n}\n\n/**\n * Transforms mapping from a model name to a model object, into an array of\n * 'named' models - models with embedded name and default value for reducers\n * if user didn't provide any.\n */\nfunction createNamedModels<TModels extends Models<TModels>>(\n\tmodels: TModels | Partial<TModels>\n): NamedModel<TModels>[] {\n\treturn Object.keys(models).map((modelName: string) => {\n\t\tconst model = createNamedModel(modelName, (models as TModels)[modelName])\n\t\tvalidateModel(model)\n\t\treturn model\n\t})\n}\n\n/**\n * Transforms a model into 'named' model - model which contains 'name' and\n * 'reducers' properties if user didn't provide any.\n */\nfunction createNamedModel<TModels extends Models<TModels>>(\n\tname: string,\n\tmodel: Model<TModels>\n): NamedModel<TModels> {\n\treturn {\n\t\tname,\n\t\treducers: {},\n\t\t...model,\n\t}\n}\n","import { Middleware } from 'redux'\nimport {\n\tAction,\n\tConfig,\n\tExposedFunction,\n\tModels,\n\tNamedModel,\n\tObjectNotAFunction,\n\tPlugin,\n\tRematchBag,\n\tRematchStore,\n\tModelDispatcher,\n\tRematchDispatch,\n} from './types'\nimport createReduxStore, {\n\tcreateModelReducer,\n\tcreateRootReducer,\n} from './reduxStore'\nimport createDispatcher from './dispatcher'\nimport { validateModel } from './validate'\nimport createRematchBag from './bag'\n\nexport default function createRematchStore<\n\tTModels extends Models<TModels>,\n\tTExtraModels extends Models<TModels>\n>(config: Config<TModels, TExtraModels>): RematchStore<TModels, TExtraModels> {\n\t// setup rematch 'bag' for storing useful values and functions\n\tconst bag = createRematchBag(config)\n\n\t// add middleware for handling effects\n\tbag.reduxConfig.middlewares.push(createEffectsMiddleware(bag))\n\n\t// collect middlewares from plugins\n\tbag.forEachPlugin('createMiddleware', (createMiddleware) => {\n\t\tbag.reduxConfig.middlewares.push(createMiddleware(bag))\n\t})\n\n\tconst reduxStore = createReduxStore(bag)\n\n\tlet rematchStore = {\n\t\t...reduxStore,\n\t\tname: config.name,\n\t\taddModel(model: NamedModel<TModels>) {\n\t\t\tvalidateModel(model)\n\t\t\tcreateModelReducer(bag, model)\n\t\t\tprepareModel(rematchStore, bag, model)\n\t\t\treduxStore.replaceReducer(createRootReducer(bag))\n\t\t\treduxStore.dispatch({ type: '@@redux/REPLACE' })\n\t\t},\n\t} as RematchStore<TModels, TExtraModels>\n\n\taddExposed(rematchStore, config.plugins)\n\n\t// generate dispatch[modelName][actionName] for all reducers and effects\n\tbag.models.forEach((model) => prepareModel(rematchStore, bag, model))\n\n\tbag.forEachPlugin('onStoreCreated', (onStoreCreated) => {\n\t\trematchStore = onStoreCreated(rematchStore, bag) || rematchStore\n\t})\n\n\treturn rematchStore\n}\n\nfunction createEffectsMiddleware<\n\tTModels extends Models<TModels>,\n\tTExtraModels extends Models<TModels>\n>(bag: RematchBag<TModels, TExtraModels>): Middleware {\n\treturn (store) => (next) => (action: Action): any => {\n\t\tif (action.type in bag.effects) {\n\t\t\t// first run reducer action if exists\n\t\t\tnext(action)\n\n\t\t\t// then run the effect and return its result\n\t\t\treturn (bag.effects as any)[action.type](\n\t\t\t\taction.payload,\n\t\t\t\tstore.getState(),\n\t\t\t\taction.meta\n\t\t\t)\n\t\t}\n\n\t\treturn next(action)\n\t}\n}\n\nfunction prepareModel<\n\tTModels extends Models<TModels>,\n\tTExtraModels extends Models<TModels>,\n\tTModel extends NamedModel<TModels>\n>(\n\trematchStore: RematchStore<TModels, TExtraModels>,\n\tbag: RematchBag<TModels, TExtraModels>,\n\tmodel: TModel\n): void {\n\tconst modelDispatcher = {} as ModelDispatcher<TModel, TModels>\n\n\t// inject model so effects creator can access it\n\trematchStore.dispatch[\n\t\t`${model.name}` as keyof RematchDispatch<TModels>\n\t] = modelDispatcher\n\n\tcreateDispatcher(rematchStore, bag, model)\n\n\tbag.forEachPlugin('onModel', (onModel) => {\n\t\tonModel(model, rematchStore)\n\t})\n}\n\n/**\n * Adds properties exposed by plugins into the Rematch instance. If a exposed\n * property is a function, it passes rematch as the first argument.\n *\n * If you're implementing a plugin in TypeScript, extend Rematch namespace by\n * adding the properties that you exposed from your plugin.\n */\nfunction addExposed<\n\tTModels extends Models<TModels>,\n\tTExtraModels extends Models<TModels>\n>(\n\tstore: RematchStore<TModels, TExtraModels>,\n\tplugins: Plugin<TModels, TExtraModels>[]\n): void {\n\tplugins.forEach((plugin) => {\n\t\tif (!plugin.exposed) return\n\t\tconst pluginKeys = Object.keys(plugin.exposed)\n\t\tpluginKeys.forEach((key) => {\n\t\t\tif (!plugin.exposed) return\n\t\t\tconst exposedItem = plugin.exposed[key] as\n\t\t\t\t| ExposedFunction<TModels, TExtraModels>\n\t\t\t\t| ObjectNotAFunction\n\t\t\tconst isExposedFunction = typeof exposedItem === 'function'\n\n\t\t\tstore[key] = isExposedFunction\n\t\t\t\t? (...params: any[]): any =>\n\t\t\t\t\t\t(exposedItem as ExposedFunction<TModels, TExtraModels>)(\n\t\t\t\t\t\t\tstore,\n\t\t\t\t\t\t\t...params\n\t\t\t\t\t\t)\n\t\t\t\t: Object.create(plugin.exposed[key])\n\t\t})\n\t})\n}\n","import { InitConfig, Config, Models } from './types'\nimport { validateConfig, validatePlugin } from './validate'\n\nlet count = 0\n\n/**\n * Builds complete Rematch config using default values for properties not\n * supplied by the user. Additionally, applies changes to the config made by\n * the plugins selected by the user.\n */\nexport default function createConfig<\n\tTModels extends Models<TModels>,\n\tTExtraModels extends Models<TModels>\n>(\n\tinitConfig: InitConfig<TModels, TExtraModels>\n): Config<TModels, TExtraModels> {\n\tconst storeName = initConfig.name ?? `Rematch Store ${count}`\n\n\tcount += 1\n\n\tconst config = {\n\t\tname: storeName,\n\t\tmodels: initConfig.models || {},\n\t\tplugins: initConfig.plugins || [],\n\t\tredux: {\n\t\t\treducers: {},\n\t\t\trootReducers: {},\n\t\t\tenhancers: [],\n\t\t\tmiddlewares: [],\n\t\t\t...initConfig.redux,\n\t\t\tdevtoolOptions: {\n\t\t\t\tname: storeName,\n\t\t\t\t...(initConfig.redux?.devtoolOptions ?? {}),\n\t\t\t},\n\t\t},\n\t} as Config<TModels, TExtraModels>\n\n\tvalidateConfig(config)\n\n\t// Apply changes to the config required by plugins\n\tconfig.plugins.forEach((plugin) => {\n\t\tif (plugin.config) {\n\t\t\t// Collect new models\n\t\t\tconfig.models = merge(config.models, plugin.config.models)\n\n\t\t\t// Collect redux configuration changes\n\t\t\tif (plugin.config.redux) {\n\t\t\t\tconfig.redux.initialState = merge(\n\t\t\t\t\tconfig.redux.initialState,\n\t\t\t\t\tplugin.config.redux.initialState\n\t\t\t\t)\n\n\t\t\t\tconfig.redux.reducers = merge(\n\t\t\t\t\tconfig.redux.reducers,\n\t\t\t\t\tplugin.config.redux.reducers\n\t\t\t\t)\n\n\t\t\t\tconfig.redux.rootReducers = merge(\n\t\t\t\t\tconfig.redux.rootReducers,\n\t\t\t\t\tplugin.config.redux.reducers\n\t\t\t\t)\n\n\t\t\t\tconfig.redux.enhancers = [\n\t\t\t\t\t...config.redux.enhancers,\n\t\t\t\t\t...(plugin.config.redux.enhancers || []),\n\t\t\t\t]\n\n\t\t\t\tconfig.redux.middlewares = [\n\t\t\t\t\t...config.redux.middlewares,\n\t\t\t\t\t...(plugin.config.redux.middlewares || []),\n\t\t\t\t]\n\n\t\t\t\tconfig.redux.combineReducers =\n\t\t\t\t\tconfig.redux.combineReducers || plugin.config.redux.combineReducers\n\n\t\t\t\tconfig.redux.createStore =\n\t\t\t\t\tconfig.redux.createStore || plugin.config.redux.createStore\n\t\t\t}\n\t\t}\n\n\t\tvalidatePlugin(plugin)\n\t})\n\n\treturn config as Config<TModels, TExtraModels>\n}\n\n/**\n * Shallow merges original object with the extra object, giving the precedence\n * to the original object.\n */\nfunction merge<\n\tT extends Record<string, unknown>,\n\tU extends Record<string, unknown> = T\n>(original: T, extra?: U): T | (T & U) {\n\treturn extra ? { ...extra, ...original } : original\n}\n","import createRematchStore from './rematchStore'\nimport { InitConfig, Models, RematchStore, ModelCreator } from './types'\nimport createConfig from './config'\n\n/**\n * Prepares a complete configuration and creates a Rematch store.\n */\nexport const init = <\n\tTModels extends Models<TModels>,\n\tTExtraModels extends Models<TModels> = Record<string, never>\n>(\n\tinitConfig?: InitConfig<TModels, TExtraModels>\n): RematchStore<TModels, TExtraModels> => {\n\tconst config = createConfig(initConfig || {})\n\treturn createRematchStore(config)\n}\n\nexport const createModel: ModelCreator = () => (mo): any => {\n\tconst { reducers = {}, effects = {} } = mo\n\n\treturn {\n\t\t...mo,\n\t\treducers,\n\t\teffects,\n\t}\n}\n\nexport default {\n\tinit,\n\tcreateModel,\n}\n\nexport * from './types'\n"]},"metadata":{},"sourceType":"module"}